{"version":3,"sources":["../src/engine/policy.ts","../src/engine/metrics.ts","../src/engine/cost.ts","../src/engine/execution.ts","../src/engine/scheduler.ts","../src/engine/tick.ts"],"sourcesContent":["export type PolicyName = \"FAIRNESS\" | \"BALANCED\" | \"THROUGHPUT\";\r\n\r\nexport type Policy = {\r\n  starvationWeight: number;\r\n  latenessWeight: number;\r\n  failureWeight: number;\r\n  instabilityWeight: number;\r\n};\r\n\r\nexport const POLICIES: Record<PolicyName, Policy> = {\r\n  FAIRNESS: {\r\n    starvationWeight: 2,\r\n    latenessWeight: 0.8,\r\n    failureWeight: 1,\r\n    instabilityWeight: 0.5,\r\n  },\r\n  BALANCED: {\r\n    starvationWeight: 0.5,\r\n    latenessWeight: 1,\r\n    failureWeight: 2,\r\n    instabilityWeight: 1,\r\n  },\r\n  THROUGHPUT: {\r\n    starvationWeight: 0.1,\r\n    latenessWeight: 1.5,\r\n    failureWeight: 3,\r\n    instabilityWeight: 2,\r\n  },\r\n};\r\n","import { SystemState } from \"../core/state\";\r\n\r\nexport function computeMetrics(state: SystemState): SystemState {\r\n  const usedCPU = state.workers.reduce((a, w) => a + w.usedCPU, 0);\r\n  const usedRAM = state.workers.reduce((a, w) => a + w.usedRAM, 0);\r\n\r\n  const cpuPressure = usedCPU / state.resources.totalCPU;\r\n  const ramPressure = usedRAM / state.resources.totalRAM;\r\n\r\n  return {\r\n    ...state,\r\n    metrics: {\r\n      queueLength: state.tasks.filter((t) => t.status === \"queued\").length,\r\n      cpuPressure,\r\n      ramPressure,\r\n      pressure: Math.max(cpuPressure, ramPressure),\r\n      completed: state.tasks.filter((t) => t.status === \"completed\").length,\r\n      failed: state.tasks.filter((t) => t.status === \"failed\").length,\r\n    },\r\n  };\r\n}\r\n","import { Task } from \"../core/task\";\r\nimport { SystemState } from \"../core/state\";\r\nimport { POLICIES } from \"./policy\";\r\n\r\nexport type CostBreakdown = {\r\n  starvation: number;\r\n  lateness: number;\r\n  failureRisk: number;\r\n  instability: number;\r\n  total: number;\r\n};\r\n\r\nexport function computeTaskCost(task: Task, state: SystemState): CostBreakdown {\r\n  const policy = POLICIES[state.policy];\r\n  const now = state.time;\r\n  const pressure = state.metrics.pressure;\r\n\r\n  // --- Starvation ---\r\n  const waitingTime = task.startedAt === undefined ? now - task.createdAt : 0;\r\n\r\n  const starvation = waitingTime * policy.starvationWeight;\r\n\r\n  // --- Lateness ---\r\n  const latenessTime = Math.max(0, now - task.deadline);\r\n\r\n  const lateness = latenessTime * policy.latenessWeight;\r\n\r\n  // --- Failure Risk (expected loss) ---\r\n  const failureRisk = task.failureProbability * pressure * policy.failureWeight;\r\n\r\n  // --- System Instability ---\r\n  const instability = pressure * pressure * policy.instabilityWeight;\r\n\r\n  const total = starvation + lateness + failureRisk + instability;\r\n\r\n  return {\r\n    starvation,\r\n    lateness,\r\n    failureRisk,\r\n    instability,\r\n    total,\r\n  };\r\n}\r\n","import { ResourceCurve } from \"../core/task\";\r\nimport { RNG } from \"./random\";\r\n\r\nexport function sampleUsage(curve: ResourceCurve, rng: RNG): number {\r\n  return rng() < curve.variance ? curve.peak : curve.base;\r\n}\r\n\r\nexport function slowdownFactor(pressure: number): number {\r\n  return 1 + pressure * pressure;\r\n}\r\n","import { SystemState } from \"../core/state\";\r\nimport { computeTaskCost } from \"./cost\";\r\nimport { sampleUsage, slowdownFactor } from \"./execution\";\r\nimport { RNG } from \"./random\";\r\n\r\nconst MAX_PRESSURE = 1.2;\r\n\r\nexport function schedule(\r\n  state: SystemState,\r\n  dt: number,\r\n  rng: RNG\r\n): SystemState {\r\n  const now = state.time;\r\n\r\n  const queued = state.tasks.filter((t) => t.status === \"queued\");\r\n\r\n  // ---- Load shedding ----\r\n  if (state.metrics.pressure > MAX_PRESSURE && queued.length > 0) {\r\n    const worst = queued\r\n      .map((t) => ({ t, cost: computeTaskCost(t, state).total }))\r\n      .sort((a, b) => b.cost - a.cost)[0].t;\r\n\r\n    worst.status = \"failed\";\r\n  }\r\n\r\n  // ---- Admission control ----\r\n  const sortedQueued = queued\r\n    .map((t) => ({ t, cost: computeTaskCost(t, state).total }))\r\n    .sort((a, b) => a.cost - b.cost);\r\n\r\n  for (const { t } of sortedQueued) {\r\n    const cpu = sampleUsage(t.execution.cpuCurve, rng);\r\n    const ram = sampleUsage(t.execution.ramCurve, rng);\r\n\r\n    if (\r\n      state.metrics.cpuPressure + cpu / state.resources.totalCPU > 1 ||\r\n      state.metrics.ramPressure + ram / state.resources.totalRAM > 1\r\n    ) {\r\n      continue;\r\n    }\r\n\r\n    t.status = \"running\";\r\n    t.startedAt = now;\r\n    t.expectedEndAt = now + t.execution.meanDuration;\r\n  }\r\n\r\n  // ---- Execute running tasks ----\r\n  const running = state.tasks.filter((t) => t.status === \"running\");\r\n  const cpuTasks = running.filter((t) => t.phase === \"cpu\");\r\n  const cpuPerTask =\r\n    cpuTasks.length > 0 ? state.resources.totalCPU / cpuTasks.length : 0;\r\n\r\n  for (const t of running) {\r\n    const slow = slowdownFactor(state.metrics.pressure);\r\n\r\n    if (t.phase === \"cpu\") {\r\n      t.progress +=\r\n        ((cpuPerTask / state.resources.totalCPU) *\r\n          (dt / t.execution.meanDuration)) /\r\n        slow;\r\n    } else {\r\n      t.progress += 0.3 * (dt / t.execution.meanDuration);\r\n    }\r\n\r\n    // Correlated failure\r\n    if (rng() < t.failureProbability * state.metrics.pressure) {\r\n      t.status = \"failed\";\r\n      continue;\r\n    }\r\n\r\n    if (t.progress >= 1) {\r\n      t.status = \"completed\";\r\n    }\r\n\r\n    // Phase switching (async illusion)\r\n    if (rng() < 0.15) {\r\n      t.phase = t.phase === \"cpu\" ? \"io\" : \"cpu\";\r\n    }\r\n  }\r\n\r\n  return state;\r\n}\r\n","import { SystemState } from \"../core/state\";\r\nimport { computeMetrics } from \"./metrics\";\r\nimport { schedule } from \"./scheduler\";\r\nimport { RNG } from \"./random\";\r\n\r\nexport function tick(state: SystemState, dt: number, rng: RNG): SystemState {\r\n  let next = { ...state, time: state.time + dt };\r\n\r\n  next = computeMetrics(next);\r\n  next = schedule(next, dt, rng);\r\n  next = computeMetrics(next);\r\n\r\n  return next;\r\n}\r\n"],"mappings":"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","names":[]}