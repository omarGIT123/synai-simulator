{"version":3,"sources":["../src/engine/policy.ts","../src/engine/metrics.ts","../src/engine/cost.ts","../src/engine/execution.ts","../src/engine/scheduler.ts","../src/engine/tick.ts"],"sourcesContent":["export type PolicyName = \"FAIRNESS\" | \"BALANCED\" | \"THROUGHPUT\";\r\n\r\nexport type Policy = {\r\n  starvationWeight: number;\r\n  latenessWeight: number;\r\n  failureWeight: number;\r\n  instabilityWeight: number;\r\n};\r\n\r\nexport const POLICIES: Record<PolicyName, Policy> = {\r\n  FAIRNESS: {\r\n    starvationWeight: 2,\r\n    latenessWeight: 0.8,\r\n    failureWeight: 1,\r\n    instabilityWeight: 0.5,\r\n  },\r\n  BALANCED: {\r\n    starvationWeight: 0.5,\r\n    latenessWeight: 1,\r\n    failureWeight: 2,\r\n    instabilityWeight: 1,\r\n  },\r\n  THROUGHPUT: {\r\n    starvationWeight: 0.1,\r\n    latenessWeight: 1.5,\r\n    failureWeight: 3,\r\n    instabilityWeight: 2,\r\n  },\r\n};\r\n","import { SystemState } from \"../core/state\";\r\n\r\nexport function computeMetrics(state: SystemState): SystemState {\r\n  let usedCPU = 0;\r\n  let usedRAM = 0;\r\n\r\n  for (const task of state.tasks) {\r\n    if (task.status === \"running\") {\r\n      usedCPU += task.execution.cpuCurve.base;\r\n      usedRAM += task.execution.ramCurve.base;\r\n    }\r\n  }\r\n\r\n  const cpuPressure = usedCPU / state.resources.totalCPU;\r\n  const ramPressure = usedRAM / state.resources.totalRAM;\r\n  const pressure = Math.max(cpuPressure, ramPressure);\r\n\r\n  const queueLength = state.tasks.filter((t) => t.status === \"queued\").length;\r\n\r\n  const failed = state.tasks.filter((t) => t.status === \"failed\").length;\r\n\r\n  // ðŸ”¥ System Stability Index (0â€“100)\r\n  const pressurePenalty = Math.min(pressure * 50, 60);\r\n  const queuePenalty = Math.min(queueLength * 3, 25);\r\n  const failurePenalty = Math.min(failed * 5, 40);\r\n\r\n  const stabilityIndex = Math.max(\r\n    0,\r\n    Math.round(100 - pressurePenalty - queuePenalty - failurePenalty)\r\n  );\r\n\r\n  state.metrics = {\r\n    ...state.metrics,\r\n    cpuPressure,\r\n    ramPressure,\r\n    pressure,\r\n    queueLength,\r\n    completed: state.tasks.filter((t) => t.status === \"completed\").length,\r\n    failed,\r\n    stabilityIndex,\r\n  };\r\n\r\n  return state;\r\n}\r\n","import { Task } from \"../core/task\";\r\nimport { SystemState } from \"../core/state\";\r\nimport { POLICIES } from \"./policy\";\r\n\r\nexport type CostBreakdown = {\r\n  starvation: number;\r\n  lateness: number;\r\n  failureRisk: number;\r\n  instability: number;\r\n  total: number;\r\n};\r\n\r\nexport function computeTaskCost(task: Task, state: SystemState): CostBreakdown {\r\n  const policy = POLICIES[state.policy];\r\n  const now = state.time;\r\n  const pressure = state.metrics.pressure;\r\n\r\n  // --- Starvation ---\r\n  const waitingTime = task.startedAt === undefined ? now - task.createdAt : 0;\r\n\r\n  const starvation = waitingTime * policy.starvationWeight;\r\n\r\n  // --- Lateness ---\r\n  const latenessTime = Math.max(0, now - task.deadline);\r\n\r\n  const lateness = latenessTime * policy.latenessWeight;\r\n\r\n  // --- Failure Risk (expected loss) ---\r\n  const failureRisk = task.failureProbability * pressure * policy.failureWeight;\r\n\r\n  // --- System Instability ---\r\n  const instability = pressure * pressure * policy.instabilityWeight;\r\n\r\n  const total = starvation + lateness + failureRisk + instability;\r\n\r\n  return {\r\n    starvation,\r\n    lateness,\r\n    failureRisk,\r\n    instability,\r\n    total,\r\n  };\r\n}\r\n","import { ResourceCurve } from \"../core/task\";\r\nimport { RNG } from \"./random\";\r\n\r\nexport function sampleUsage(curve: ResourceCurve, rng: RNG): number {\r\n  const spread = curve.peak - curve.base;\r\n\r\n  // centered noise in [-0.5, 0.5]\r\n  const noise = (rng() - 0.5) * 2;\r\n\r\n  const usage = curve.base + spread * curve.variance * noise;\r\n\r\n  return Math.max(0, usage);\r\n}\r\n\r\nexport function slowdownFactor(pressure: number): number {\r\n  return 1 + pressure * pressure;\r\n}\r\n","import { SystemState } from \"../core/state\";\r\nimport { computeTaskCost } from \"./cost\";\r\nimport { slowdownFactor } from \"./execution\";\r\nimport { RNG } from \"./random\";\r\nimport { sampleUsage } from \"./execution\";\r\n\r\nconst MAX_PRESSURE = 1.2;\r\n\r\nfunction phaseFailureMultiplier(phase: \"cpu\" | \"io\") {\r\n  return phase === \"io\" ? 1.6 : 1.0;\r\n}\r\n\r\nexport function schedule(\r\n  state: SystemState,\r\n  dt: number,\r\n  rng: RNG\r\n): SystemState {\r\n  const now = state.time;\r\n\r\n  /* =========================================================\r\n     1. STARVATION FAILURE (queued too long, under pressure)\r\n     ========================================================= */\r\n\r\n  for (const t of state.tasks) {\r\n    if (\r\n      t.status === \"queued\" &&\r\n      t.maxQueueTime !== undefined &&\r\n      now - t.createdAt > t.maxQueueTime &&\r\n      state.metrics.pressure > 1\r\n    ) {\r\n      t.status = \"failed\";\r\n      t.failureType = \"starvation\";\r\n      t.failureReason =\r\n        \"Starvation: task waited too long in queue under pressure\";\r\n    }\r\n  }\r\n\r\n  const queued = state.tasks.filter((t) => t.status === \"queued\");\r\n\r\n  /* =========================================================\r\n     2. LOAD SHEDDING (system protection)\r\n     ========================================================= */\r\n\r\n  if (state.metrics.pressure > MAX_PRESSURE && queued.length > 0) {\r\n    const worst = queued\r\n      .map((t) => ({ t, cost: computeTaskCost(t, state).total }))\r\n      .sort((a, b) => b.cost - a.cost)[0].t;\r\n\r\n    worst.status = \"failed\";\r\n    worst.failureType = \"load_shed\";\r\n    worst.failureReason = \"Load shed: system pressure exceeded safe threshold\";\r\n  }\r\n\r\n  /* =========================================================\r\n     3. ADMISSION CONTROL (concurrency-limited)\r\n     ========================================================= */\r\n\r\n  const queuedWithCost = state.tasks\r\n    .filter((t) => t.status === \"queued\")\r\n    .map((t) => ({ t, cost: computeTaskCost(t, state).total }));\r\n\r\n  let sortedQueued;\r\n\r\n  switch (state.policy) {\r\n    case \"THROUGHPUT\":\r\n      // favor cheap tasks â†’ maximize completions\r\n      sortedQueued = queuedWithCost.sort((a, b) => a.cost - b.cost);\r\n      break;\r\n\r\n    case \"FAIRNESS\":\r\n      // favor oldest tasks\r\n      sortedQueued = queuedWithCost.sort(\r\n        (a, b) => a.t.createdAt - b.t.createdAt\r\n      );\r\n      break;\r\n\r\n    case \"BALANCED\":\r\n    default:\r\n      // mix age + cost\r\n      sortedQueued = queuedWithCost.sort(\r\n        (a, b) =>\r\n          0.5 * (a.cost - b.cost) + 0.5 * (a.t.createdAt - b.t.createdAt)\r\n      );\r\n  }\r\n\r\n  let runningCount = state.tasks.filter((t) => t.status === \"running\").length;\r\n\r\n  for (const { t } of sortedQueued) {\r\n    if (runningCount >= state.config.maxConcurrentTasks) break;\r\n\r\n    t.status = \"running\";\r\n    t.startedAt = now;\r\n    t.expectedEndAt = now + t.execution.meanDuration;\r\n\r\n    t.currentRAM = sampleUsage(t.execution.ramCurve, rng);\r\n\r\n    runningCount++;\r\n  }\r\n\r\n  /* =========================================================\r\n     4. EXECUTE RUNNING TASKS\r\n     ========================================================= */\r\n\r\n  const running = state.tasks.filter((t) => t.status === \"running\");\r\n\r\n  /* ---------- CPU SHARING ---------- */\r\n  const cpuTasks = running.filter((t) => t.phase === \"cpu\");\r\n  const cpuPerTask =\r\n    cpuTasks.length > 0 ? state.resources.totalCPU / cpuTasks.length : 0;\r\n\r\n  /* ---------- RAM ACCUMULATION ---------- */\r\n  let totalUsedRAM = 0;\r\n  for (const t of running) {\r\n    if (t.currentRAM !== undefined) {\r\n      totalUsedRAM += t.currentRAM;\r\n    }\r\n  }\r\n\r\n  state.metrics.ramPressure = totalUsedRAM / state.resources.totalRAM;\r\n\r\n  /* ---------- EXECUTION LOOP ---------- */\r\n  for (const t of running) {\r\n    const cpuSlow = slowdownFactor(state.metrics.cpuPressure);\r\n\r\n    if (t.phase === \"cpu\") {\r\n      t.progress +=\r\n        ((cpuPerTask / state.resources.totalCPU) *\r\n          (dt / t.execution.meanDuration)) /\r\n        cpuSlow;\r\n    } else {\r\n      const ramSlow = 1 + Math.max(0, state.metrics.ramPressure - 1);\r\n\r\n      t.progress += (0.3 * dt) / t.execution.meanDuration / ramSlow;\r\n    }\r\n\r\n    /* ---------- TIMEOUT FAILURE ---------- */\r\n    if (t.deadline !== undefined && t.startedAt !== undefined) {\r\n      const effectiveDeadline =\r\n        t.deadline * Math.max(1, state.metrics.pressure);\r\n\r\n      if (now - t.startedAt > effectiveDeadline && state.metrics.pressure > 1) {\r\n        t.status = \"failed\";\r\n        t.failureType = \"timeout\";\r\n        t.failureReason = \"Deadline exceeded under sustained pressure\";\r\n        continue;\r\n      }\r\n    }\r\n\r\n    /* ---------- PRESSURE-CORRELATED FAILURE ---------- */\r\n    const runTime = t.startedAt !== undefined ? now - t.startedAt : 0;\r\n\r\n    const fatigueMultiplier = 1 + Math.min(runTime / 10, 1);\r\n\r\n    const lambda =\r\n      t.failureProbability *\r\n      phaseFailureMultiplier(t.phase) *\r\n      fatigueMultiplier *\r\n      state.metrics.pressure;\r\n\r\n    const perTickRisk = 1 - Math.exp(-lambda * dt);\r\n\r\n    if (rng() < perTickRisk) {\r\n      t.status = \"failed\";\r\n      t.failureType = \"pressure\";\r\n      t.failureReason = `Execution failure (Î»=${lambda.toFixed(3)})`;\r\n      continue;\r\n    }\r\n\r\n    /* ---------- COMPLETION ---------- */\r\n    if (t.progress >= 1) {\r\n      t.status = \"completed\";\r\n    }\r\n\r\n    /* ---------- ASYNC ILLUSION ---------- */\r\n    if (rng() < 0.15) {\r\n      t.phase = t.phase === \"cpu\" ? \"io\" : \"cpu\";\r\n    }\r\n  }\r\n\r\n  return state;\r\n}\r\n","import { SystemState } from \"../core/state\";\r\nimport { computeMetrics } from \"./metrics\";\r\nimport { schedule } from \"./scheduler\";\r\nimport { RNG } from \"./random\";\r\n\r\nexport function tick(state: SystemState, dt: number, rng: RNG): SystemState {\r\n  let next = { ...state, time: state.time + dt };\r\n\r\n  next = computeMetrics(next);\r\n  next = schedule(next, dt, rng);\r\n  next = computeMetrics(next);\r\n\r\n  return next;\r\n}\r\n"],"mappings":"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","names":[]}